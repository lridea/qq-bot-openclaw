# 对话记忆功能实现方案

## 📋 功能概述

为 QQ Bot 添加对话记忆功能，让机器人能够记住之前的对话历史，提供更好的连续性对话体验。

---

## 🎯 需求分析

### 当前问题
- 每次对话都是独立的，没有上下文
- 机器人不记得之前说过什么
- 无法保持对话的连贯性

### 需要实现
- 记住最近的对话历史
- 支持"上下文感知"的回复
- 重启后能恢复对话历史
- 支持多用户、多群组的独立记忆

---

## 🏗️ 架构设计

### 分层记忆架构

```
┌─────────────────────────────────────────────┐
│            对话记忆系统                        │
├─────────────────────────────────────────────┤
│  Layer 1: 短期记忆（内存）                   │
│  - 存储最近 N 条消息                         │
│  - 快速访问                                 │
│  - 重启后丢失                               │
├─────────────────────────────────────────────┤
│  Layer 2: 长期记忆（文件）                   │
│  - 持久化保存对话摘要                        │
│  - 重启后恢复                               │
│  - 按用户/群组分类存储                      │
├─────────────────────────────────────────────┤
│  Layer 3: 记忆管理器                        │
│  - 统一管理短期和长期记忆                    │
│  - 提供查询和更新接口                        │
│  - 自动清理过期记忆                          │
└─────────────────────────────────────────────┘
```

---

## 🔧 技术方案

### 方案1：内存记忆（简单版）

**特点：**
- ✅ 实现简单，无需额外依赖
- ✅ 性能高，读写速度快
- ❌ 重启后丢失
- ❌ 内存占用较大

**适用场景：**
- 单进程运行
- 不需要长期记忆
- 对性能要求高

**实现方式：**
```python
# 内存中存储对话历史
memory = {
    "user_123456": [
        {"role": "user", "content": "你好"},
        {"role": "assistant", "content": "你好呀！"}
    ],
    "group_789012": [...]
}
```

### 方案2：文件存储（推荐版）⭐

**特点：**
- ✅ 持久化，重启不丢失
- ✅ 实现简单，无需额外依赖
- ✅ 便于调试和备份
- ⚠️ 性能一般，文件读写
- ⚠️ 并发处理需要注意

**适用场景：**
- 需要持久化记忆
- 单进程运行
- 易于调试

**实现方式：**
```python
# 按用户/群组存储对话历史
data/
├── conversations/
│   ├── user_123456.json
│   ├── group_789012.json
│   └── ...
└── summaries/
    ├── user_123456_summary.json
    └── ...
```

### 方案3：数据库存储（完善版）

**特点：**
- ✅ 性能好，支持并发
- ✅ 查询方便
- ✅ 支持复杂查询
- ❌ 需要部署数据库
- ❌ 实现复杂

**适用场景：**
- 多进程/分布式部署
- 需要高性能
- 需要复杂查询

**数据库选择：**
- **SQLite**：轻量级，无需部署
- **Redis**：高性能，支持过期时间
- **MySQL/PostgreSQL**：功能完善

### 方案4：Redis 缓存（高性能版）

**特点：**
- ✅ 性能极高
- ✅ 支持过期时间（自动清理）
- ✅ 支持并发
- ❌ 需要部署 Redis
- ❌ 需要额外依赖

**适用场景：**
- 高并发场景
- 需要自动清理过期记忆
- 对性能要求极高

---

## 🎯 推荐方案：分层记忆系统

结合以上方案的优点，我推荐实现一个**分层记忆系统**：

### 架构设计

```
┌─────────────────────────────────────────────┐
│            分层记忆系统                        │
├─────────────────────────────────────────────┤
│  Layer 1: 短期记忆（内存）                   │
│  - 存储最近 N 条消息（如 10 条）             │
│  - 快速访问，传递给 AI 作为上下文              │
├─────────────────────────────────────────────┤
│  Layer 2: 长期记忆（SQLite）                 │
│  - 持久化保存所有对话历史                     │
│  - 支持查询和恢复                             │
│  - 定期清理过期数据                           │
├─────────────────────────────────────────────┤
│  Layer 3: 记忆管理器                         │
│  - 统一管理所有记忆                           │
│  - 提供简洁的 API                            │
│  - 自动清理过期记忆                           │
└─────────────────────────────────────────────┘
```

### 实现特点

1. **双重存储**
   - 短期记忆（内存）：快速访问，传递给 AI
   - 长期记忆（SQLite）：持久化，重启恢复

2. **配置化**
   - 可配置记忆长度
   - 可配置过期时间
   - 可选择启用/禁用

3. **自动管理**
   - 自动保存对话
   - 自动清理过期记忆
   - 自动压缩长期记忆

4. **多维度记忆**
   - 按用户 ID 记忆（私聊）
   - 按群组 ID 记忆（群聊）
   - 独立存储，互不干扰

---

## 📝 配置设计

### 环境变量配置（.env）

```ini
# ========== 对话记忆配置 ==========
# 是否启用对话记忆功能
MEMORY_ENABLED=true

# 记忆存储方式：sqlite/file/memory
MEMORY_STORAGE=sqlite

# 短期记忆长度（内存中保存的消息数量）
MEMORY_SHORT_TERM_LENGTH=10

# 长期记忆过期时间（天），0 表示永不过期
MEMORY_LONG_TERM_EXPIRE_DAYS=30

# 是否自动清理过期记忆
MEMORY_AUTO_CLEAN=true

# 对话摘要开关（保存对话摘要，节省空间）
MEMORY_SUMMARY_ENABLED=true
```

### 配置项说明

| 配置项 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `MEMORY_ENABLED` | bool | `true` | 是否启用对话记忆 |
| `MEMORY_STORAGE` | string | `sqlite` | 存储方式（sqlite/file/memory）|
| `MEMORY_SHORT_TERM_LENGTH` | int | `10` | 短期记忆长度（消息数量）|
| `MEMORY_LONG_TERM_EXPIRE_DAYS` | int | `30` | 长期记忆过期时间（天）|
| `MEMORY_AUTO_CLEAN` | bool | `true` | 是否自动清理过期记忆 |
| `MEMORY_SUMMARY_ENABLED` | bool | `true` | 是否保存对话摘要 |

---

## 🚀 实现计划

### 阶段1：基础功能（文件存储）

1. 创建对话记忆模块（`conversation_memory.py`）
2. 实现基础的记忆存储（JSON 文件）
3. 集成到 AI 处理流程
4. 测试和优化

**预计工作量：** 2-3 小时

### 阶段2：分层记忆（SQLite）

1. 实现短期记忆（内存）
2. 实现长期记忆（SQLite）
3. 实现记忆管理器
4. 自动清理过期记忆

**预计工作量：** 3-4 小时

### 阶段3：高级功能

1. 对话摘要功能
2. 记忆搜索功能
3. 记忆导出功能
4. Web 界面管理记忆

**预计工作量：** 4-5 小时

---

## 📊 方案对比

| 方案 | 复杂度 | 性能 | 持久化 | 并发 | 推荐度 |
|------|--------|------|--------|------|--------|
| 内存记忆 | ⭐ | ⭐⭐⭐⭐⭐ | ❌ | ⭐ | ⭐⭐ |
| 文件存储 | ⭐⭐ | ⭐⭐⭐ | ✅ | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| SQLite 存储 | ⭐⭐⭐ | ⭐⭐⭐⭐ | ✅ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| Redis 缓存 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ✅ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |

---

## 💡 推荐实现步骤

### 第一步：文件存储（快速实现）

实现基于 JSON 文件的对话记忆，快速验证功能。

**优点：**
- 实现简单
- 便于调试
- 快速上线

**缺点：**
- 性能一般
- 并发处理有限

### 第二步：SQLite 存储（优化性能）

升级到 SQLite 数据库，提升性能和可靠性。

**优点：**
- 性能好
- 支持复杂查询
- 持久化可靠

**缺点：**
- 实现稍复杂
- 需要数据库知识

### 第三步：Redis 缓存（极致性能）

添加 Redis 缓存层，提升并发性能。

**优点：**
- 性能极高
- 支持过期时间
- 天然支持分布式

**缺点：**
- 需要部署 Redis
- 实现复杂

---

## 🎯 我的建议

**推荐方案：文件存储 + SQLite 分层记忆**

**理由：**
1. **实现简单**：不需要额外部署
2. **功能完善**：支持持久化、查询、清理
3. **性能良好**：SQLite 性能足够
4. **易于扩展**：后续可以升级到 Redis

**实施计划：**
1. 先实现文件存储版本（快速验证）
2. 收集用户反馈
3. 升级到 SQLite 分层记忆
4. 根据需求添加高级功能

---

## 📚 相关文档

- [NoneBot2 文档](https://nonebot.dev/)
- [SQLite 教程](https://www.sqlitetutorial.net/)
- [Redis 教程](https://redis.io/docs/)

---

**文档版本：1.0.0**
**最后更新：2026-02-16**
